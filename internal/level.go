package zen_doctor

import (
	"fmt"
	"math/rand"
	"time"
)

type LevelConfig struct {
	Level              Level
	Width              int                  // Width of map
	Height             int                  // Height of map
	ViewDist           float64              // radius in which the player can view. automatically scaled 2x in the X direction.
	FPS                float32              // How fast the bit stream renders
	FootprintDecay     float32              // How fast footprints disappear
	ThreatDecay        float32              // how fast threat meter decays
	MovementThreat     float32              // how much threat per step
	MaxThreat          float32              // total amount of threat before game over
	BitStreamChance    float32              // % chance a bit will appear
	GoodBitChance      float32              // % chance a bit will be good
	BadBitChance       float32              // % chance a bit will be good
	ThreatByRarity     map[Rarity]float32   // amount of threat generated by stream, based on their rarity
	LeaveSpeed         float32              // how fast the player can leave the room
	LeaveSpeedDecay    float32              // how fast the player can leave the room
	InitialData        int                  // how much data is spawned into the world when it's loaded
	DefaultData        DataKind             // in case we need to spawn loot and the loot table comes up empty
	LootSpeed          float32              // how fast loot meter fills when looting
	LootSpeedDecay     float32              // how fast loot meter falls when looting is interrupted
	DataSpawnRate      float32              // how fast new loot is spawned into the world
	DataDecayRate      float32              // how fast loot in the world decays
	DataLootTable      lootTable            // % chance for loot to be spawned - values in this table should add to 1
	InitialPowerUps    int                  // how many power ups are spawned into the world at the beginning
	DefaultPowerUp     PowerUpKind          // what kind of power up to grant by default
	PowerUpSpawnRate   float32              // how fast new power ups are spawned
	PowerUpDecayRate   float32              // how fast power ups that are spawned decay
	PowerUpLootTable   lootTable            // % chance for power ups to be spawned - values in this table should add to 1
	LootChanceByRarity map[Rarity]float32   // % chance for loot to be a specific rarity
	DataByRarity       map[Rarity]float32   // how much data is worth, by loot rarity
	DataMultipliers    map[DataKind]float32 // multiplier for how much data is worth, by loot type
	WinConditions      []WinCondition       // what is required to unlock the exit to this room
	Updater            BitStreamUpdater     // different levels have different bit streams
}

func (l LevelConfig) Name() string {
	return l.Level.String()
}

func (l LevelConfig) IsValid() bool {
	return l.Level.IsValid() && l.Width > 0 && l.Height > 0
}

type WinCondition struct {
	Kind   DataKind
	Amount float32
}

func (w WinCondition) IsMet(state *GameState) bool {
	if amount, ok := state.player.DataCollected[w.Kind]; ok {
		return amount >= w.Amount
	}
	return false
}

type LootTable interface {
	Chance(int) float32
	Len() int
}

// Given a loot table, this will pick one and return its index.
func pickOne(options LootTable) int {

	picked := rand.Float32()
	lower := float32(0.0)
	for i := 0; i < options.Len(); i++ {
		upper := lower + options.Chance(i)
		if picked >= lower && picked < upper {
			return i
		}
		lower = upper
	}
	return 0 // :shrug:
}

type Level int

const (
	Tutorial Level = iota
	Level1
	Level2
	Level3
	Level4
	Level5
)

func (l Level) Equals(i int) bool {
	return int(l) == i
}

func (l Level) Inc() Level {
	return l + 1
}

func (l Level) Dec() Level {
	return l - 1
}

func (l Level) IsValid() bool {
	return l >= Tutorial && l <= Level5
}

func (l Level) String() string {
	switch l {
	case Tutorial:
		return "Level 0: Tutorial"
	default:
		return fmt.Sprintf("Level %d", int(l))
	}
}

func defaultLevel() LevelConfig {
	return LevelConfig{
		Level:           Tutorial,
		Width:           100,
		Height:          20,
		ViewDist:        7.5,
		FPS:             1.25,
		FootprintDecay:  -1,
		ThreatDecay:     -0.03,
		MovementThreat:  0.3,
		MaxThreat:       50,
		BitStreamChance: 0.2,
		GoodBitChance:   0.02,
		BadBitChance:    0.1,
		ThreatByRarity: map[Rarity]float32{
			Legendary: 20,
			Epic:      15,
			Rare:      10,
			Uncommon:  8,
			Common:    5,
			Junk:      4,
		},
		LeaveSpeed:      2,
		LeaveSpeedDecay: -0.1,
		InitialData:     1,
		DefaultData:     DataKindDelta,
		LootSpeed:       1,
		LootSpeedDecay:  -0.3,
		DataSpawnRate:   0.003,
		DataDecayRate:   -0.001,
		DataLootTable: lootTable{
			{Data: DataKindDelta, Chance: 1.00},
		},
		DefaultPowerUp:   PowerUpVisionRange,
		PowerUpSpawnRate: 0,
		PowerUpDecayRate: -0.0001,
		PowerUpLootTable: lootTable{
			{PowerUp: PowerUpBadBitImmunity, Chance: 0.20},
			{PowerUp: PowerUpLootSpeed, Chance: 0.20},
			{PowerUp: PowerUpBadBitsAreGood, Chance: 0.20},
			{PowerUp: PowerUpThreatDecay, Chance: 0.20},
			{PowerUp: PowerUpVisionRange, Chance: 0.20},
		},
		LootChanceByRarity: map[Rarity]float32{
			Legendary: 0.005,
			Epic:      0.05,
			Rare:      0.25,
			Uncommon:  0.50,
			Common:    1.00,
		},
		DataByRarity: map[Rarity]float32{
			Legendary: 1000,
			Epic:      200,
			Rare:      80,
			Uncommon:  40,
			Common:    25,
			Junk:      1,
		},
		DataMultipliers: map[DataKind]float32{
			DataKindDelta:  1,
			DataKindLambda: 1,
			DataKindSigma:  1,
			DataKindOmega:  1,
		},
		WinConditions: []WinCondition{
			{
				Kind:   DataKindDelta,
				Amount: 100,
			},
		},
		Updater: newLinearBitStream(MoveLeft),
	}
}

func GetLevel(level Level) LevelConfig {
	l := defaultLevel()
	l.Level = level

	// customize defaults for the requested level
	switch level {
	case Level1:
		l.FPS = 2
		l.BitStreamChance = 0.25
		l.PowerUpSpawnRate = 0.001
		l.WinConditions = []WinCondition{
			{Kind: DataKindDelta, Amount: 200},
			{Kind: DataKindLambda, Amount: 50},
		}
		l.DataLootTable = lootTable{
			{Data: DataKindDelta, Chance: 0.66},
			{Data: DataKindLambda, Chance: 0.34},
		}
		l.DataMultipliers[DataKindDelta] = 1.2
		l.Updater = newLoopingBitStream(bitStreamStep{
			dir:   MoveLeft,
			delay: 10 * time.Second,
		}, bitStreamStep{
			dir:   MoveDownLeft,
			delay: 5 * time.Second,
		}, bitStreamStep{
			dir:   MoveLeft,
			delay: 10 * time.Second,
		}, bitStreamStep{
			dir:   MoveUpLeft,
			delay: 5 * time.Second,
		})

	case Level2:
		l.FPS = 3
		l.BitStreamChance = 0.35
		l.InitialData = 2
		l.DataSpawnRate = 0.004
		l.InitialPowerUps = 1
		l.PowerUpSpawnRate = 0.002
		l.ViewDist = 8.5
		l.WinConditions = []WinCondition{
			{Kind: DataKindDelta, Amount: 300},
			{Kind: DataKindLambda, Amount: 100},
			{Kind: DataKindSigma, Amount: 25},
		}
		l.DataLootTable = lootTable{
			{Data: DataKindDelta, Chance: 0.50},
			{Data: DataKindLambda, Chance: 0.25},
			{Data: DataKindSigma, Chance: 0.25},
		}
		l.DataMultipliers = map[DataKind]float32{
			DataKindDelta:  1.5,
			DataKindLambda: 1.2,
			DataKindSigma:  1,
		}
		l.Updater = newLoopingBitStream(rotatingBitStream(10*time.Second, 20*time.Second, 5*time.Second)...)

	case Level3:
		l.FPS = 4
		l.BitStreamChance = 0.45
		l.InitialData = 3
		l.DataSpawnRate = 0.008
		l.InitialPowerUps = 1
		l.PowerUpSpawnRate = 0.003
		l.ViewDist = 9.5
		l.WinConditions = []WinCondition{
			{Kind: DataKindDelta, Amount: 500},
			{Kind: DataKindLambda, Amount: 200},
			{Kind: DataKindSigma, Amount: 100},
			{Kind: DataKindOmega, Amount: 20},
		}
		l.DataLootTable = lootTable{
			{Data: DataKindDelta, Chance: 0.40},
			{Data: DataKindLambda, Chance: 0.25},
			{Data: DataKindSigma, Chance: 0.20},
			{Data: DataKindOmega, Chance: 0.15},
		}
		l.DataMultipliers = map[DataKind]float32{
			DataKindDelta:  2,
			DataKindLambda: 1.5,
			DataKindSigma:  1.2,
			DataKindOmega:  1,
		}
		l.Updater = newLoopingBitStream(zigZagBitStream(20*time.Second, 5*time.Second)...)

	case Level4:
		l.FPS = 5.5
		l.BitStreamChance = 0.5
		l.InitialData = 4
		l.DataSpawnRate = 0.01
		l.InitialPowerUps = 2
		l.PowerUpSpawnRate = 0.004
		l.ViewDist = 10.5
		l.WinConditions = []WinCondition{
			{Kind: DataKindDelta, Amount: 750},
			{Kind: DataKindLambda, Amount: 500},
			{Kind: DataKindSigma, Amount: 250},
			{Kind: DataKindOmega, Amount: 75},
		}
		l.DataLootTable = lootTable{
			{Data: DataKindDelta, Chance: 0.40},
			{Data: DataKindLambda, Chance: 0.25},
			{Data: DataKindSigma, Chance: 0.20},
			{Data: DataKindOmega, Chance: 0.15},
		}
		l.DataMultipliers = map[DataKind]float32{
			DataKindDelta:  2.5,
			DataKindLambda: 1.8,
			DataKindSigma:  1.5,
			DataKindOmega:  1.2,
		}
		l.Updater = newLoopingBitStream(rotatingBitStream(10*time.Second, 5*time.Second, 20*time.Second)...)

	case Level5:
		l.FPS = 7
		l.BitStreamChance = 0.5
		l.InitialData = 5
		l.DataSpawnRate = 0.02
		l.InitialPowerUps = 3
		l.PowerUpSpawnRate = 0.005
		l.ViewDist = 11.5
		l.WinConditions = []WinCondition{
			{Kind: DataKindDelta, Amount: 1000},
			{Kind: DataKindLambda, Amount: 1000},
			{Kind: DataKindSigma, Amount: 500},
			{Kind: DataKindOmega, Amount: 100},
		}
		l.DataLootTable = lootTable{
			{Data: DataKindDelta, Chance: 0.40},
			{Data: DataKindLambda, Chance: 0.25},
			{Data: DataKindSigma, Chance: 0.20},
			{Data: DataKindOmega, Chance: 0.15},
		}
		l.DataMultipliers = map[DataKind]float32{
			DataKindDelta:  3,
			DataKindLambda: 3,
			DataKindSigma:  1.8,
			DataKindOmega:  1.2,
		}
		l.Updater = newRandomBitStream(rotatingBitStream(10*time.Second, 5*time.Second, 20*time.Second)...)
	}
	return l
}
