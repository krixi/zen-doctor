package zen_doctor

import (
	"fmt"
	"time"
)

type LevelConfig struct {
	Level              Level
	Width              int                  // Width of map
	Height             int                  // Height of map
	ViewDist           float64              // radius in which the player can view. automatically scaled 2x in the X direction.
	FPS                float32              // How fast the bit stream renders
	FootprintDecay     float32              // How fast footprints disappear
	ThreatDecay        float32              // how fast threat meter decays
	MovementThreat     float32              // how much threat per step
	MaxThreat          float32              // total amount of threat before game over
	BitStreamChance    float32              // % chance a bit will appear
	GoodBitChance      float32              // % chance a bit will be good
	BadBitChance       float32              // % chance a bit will be good
	ThreatByRarity     map[Rarity]float32   // amount of threat generated by stream, based on their rarity
	LeaveSpeed         float32              // how fast the player can leave the room
	LeaveSpeedDecay    float32              // how fast the player can leave the room
	InitialLoot        int                  // how much loot is spawned into the world when it's loaded
	DefaultLootType    LootType             // in case we need to spawn loot and the loot table comes up empty
	LootSpeed          float32              // how fast loot meter fills when looting
	LootSpeedDecay     float32              // how fast loot meter falls when looting is interrupted
	LootSpawnRate      float32              // how fast new loot is spawned into the world
	LootDecayRate      float32              // how fast loot in the world decays
	LootTable          map[LootType]float32 // % chance for loot to be spawned - values in this table should add to 1
	LootChanceByRarity map[Rarity]float32   // % chance for loot to be a specific rarity
	DataByRarity       map[Rarity]float32   // how much data is worth, by loot rarity
	DataMultipliers    map[LootType]float32 // multiplier for how much data is worth, by loot type
	WinConditions      []WinCondition       // what is required to unlock the exit to this room
	Updater            BitStreamUpdater     // different levels have different bit streams
}

func (l LevelConfig) Name() string {
	return l.Level.String()
}

func (l LevelConfig) IsValid() bool {
	return l.Level.IsValid() && l.Width > 0 && l.Height > 0
}

type WinCondition struct {
	Type   LootType
	Amount float32
}

func (w WinCondition) IsMet(state *GameState) bool {
	if amount, ok := state.player.DataCollected[w.Type]; ok {
		return amount >= w.Amount
	}
	return false
}

type Level int

const (
	Tutorial Level = iota
	Level1
	Level2
	Level3
	Level4
	Level5
)

func (l Level) Equals(i int) bool {
	return int(l) == i
}

func (l Level) Inc() Level {
	return l + 1
}

func (l Level) Dec() Level {
	return l - 1
}

func (l Level) IsValid() bool {
	return l >= Tutorial && l <= Level5
}

func (l Level) String() string {
	switch l {
	case Tutorial:
		return "Level 0: Tutorial"
	default:
		return fmt.Sprintf("Level %d", int(l))
	}
}

func defaultLevel() LevelConfig {
	return LevelConfig{
		Level:           Tutorial,
		Width:           100,
		Height:          20,
		ViewDist:        7.5,
		FPS:             1.25,
		FootprintDecay:  -1,
		ThreatDecay:     -0.03,
		MovementThreat:  0.3,
		MaxThreat:       50,
		BitStreamChance: 0.2,
		GoodBitChance:   0.02,
		BadBitChance:    0.1,
		ThreatByRarity: map[Rarity]float32{
			Legendary: 20,
			Epic:      15,
			Rare:      10,
			Uncommon:  8,
			Common:    5,
			Junk:      4,
		},
		LeaveSpeed:      2,
		LeaveSpeedDecay: -0.1,
		InitialLoot:     1,
		DefaultLootType: LootTypeDelta,
		LootSpeed:       1,
		LootSpeedDecay:  -0.3,
		LootSpawnRate:   0.003,
		LootDecayRate:   -0.001,
		LootTable: map[LootType]float32{
			LootTypeDelta: 1.00,
		},
		LootChanceByRarity: map[Rarity]float32{
			Legendary: 0.005,
			Epic:      0.05,
			Rare:      0.25,
			Uncommon:  0.50,
			Common:    1.00,
		},
		DataByRarity: map[Rarity]float32{
			Legendary: 1000,
			Epic:      200,
			Rare:      80,
			Uncommon:  40,
			Common:    25,
			Junk:      1,
		},
		DataMultipliers: map[LootType]float32{
			LootTypeDelta:  1,
			LootTypeLambda: 1,
			LootTypeSigma:  1,
			LootTypeOmega:  1,
		},
		WinConditions: []WinCondition{
			{
				Type:   LootTypeDelta,
				Amount: 100,
			},
		},
		Updater: newLinearBitStream(MoveLeft),
	}
}

func GetLevel(level Level) LevelConfig {
	l := defaultLevel()
	l.Level = level

	// customize defaults for the requested level
	switch level {
	case Level1:
		l.FPS = 2
		l.BitStreamChance = 0.25
		l.WinConditions = []WinCondition{
			{
				Type:   LootTypeDelta,
				Amount: 200,
			},
			{
				Type:   LootTypeLambda,
				Amount: 50,
			},
		}
		l.LootTable = map[LootType]float32{
			LootTypeDelta:  0.66,
			LootTypeLambda: 0.34,
		}
		l.DataMultipliers[LootTypeDelta] = 1.2
		l.Updater = newLoopingBitStream(bitStreamStep{
			dir:   MoveLeft,
			delay: 10 * time.Second,
		}, bitStreamStep{
			dir:   MoveDownLeft,
			delay: 5 * time.Second,
		}, bitStreamStep{
			dir:   MoveLeft,
			delay: 10 * time.Second,
		}, bitStreamStep{
			dir:   MoveUpLeft,
			delay: 5 * time.Second,
		})

	case Level2:
		l.FPS = 3
		l.BitStreamChance = 0.35
		l.InitialLoot = 2
		l.LootSpawnRate = 0.004
		l.ViewDist = 8.5
		l.WinConditions = []WinCondition{
			{
				Type:   LootTypeDelta,
				Amount: 300,
			},
			{
				Type:   LootTypeLambda,
				Amount: 100,
			},
			{
				Type:   LootTypeSigma,
				Amount: 25,
			},
		}
		l.LootTable = map[LootType]float32{
			LootTypeDelta:  0.50,
			LootTypeLambda: 0.25,
			LootTypeSigma:  0.25,
		}
		l.DataMultipliers = map[LootType]float32{
			LootTypeDelta:  1.5,
			LootTypeLambda: 1.2,
			LootTypeSigma:  1,
		}
		l.Updater = newLoopingBitStream(rotatingBitStream(10*time.Second, 20*time.Second, 5*time.Second)...)

	case Level3:
		l.FPS = 4
		l.BitStreamChance = 0.45
		l.InitialLoot = 3
		l.LootSpawnRate = 0.008
		l.ViewDist = 9.5
		l.WinConditions = []WinCondition{
			{
				Type:   LootTypeDelta,
				Amount: 500,
			},
			{
				Type:   LootTypeLambda,
				Amount: 200,
			},
			{
				Type:   LootTypeSigma,
				Amount: 100,
			},
			{
				Type:   LootTypeOmega,
				Amount: 20,
			},
		}
		l.LootTable = map[LootType]float32{
			LootTypeDelta:  0.40,
			LootTypeLambda: 0.25,
			LootTypeSigma:  0.20,
			LootTypeOmega:  0.15,
		}
		l.DataMultipliers = map[LootType]float32{
			LootTypeDelta:  2,
			LootTypeLambda: 1.5,
			LootTypeSigma:  1.2,
			LootTypeOmega:  1,
		}
		l.Updater = newLoopingBitStream(zigZagBitStream(20*time.Second, 5*time.Second)...)

	case Level4:
		l.FPS = 5.5
		l.BitStreamChance = 0.5
		l.InitialLoot = 4
		l.LootSpawnRate = 0.01
		l.ViewDist = 10.5
		l.WinConditions = []WinCondition{
			{
				Type:   LootTypeDelta,
				Amount: 750,
			},
			{
				Type:   LootTypeLambda,
				Amount: 500,
			},
			{
				Type:   LootTypeSigma,
				Amount: 250,
			},
			{
				Type:   LootTypeOmega,
				Amount: 75,
			},
		}
		l.LootTable = map[LootType]float32{
			LootTypeDelta:  0.40,
			LootTypeLambda: 0.25,
			LootTypeSigma:  0.20,
			LootTypeOmega:  0.15,
		}
		l.DataMultipliers = map[LootType]float32{
			LootTypeDelta:  2.5,
			LootTypeLambda: 1.8,
			LootTypeSigma:  1.5,
			LootTypeOmega:  1.2,
		}
		l.Updater = newLoopingBitStream(rotatingBitStream(10*time.Second, 5*time.Second, 20*time.Second)...)

	case Level5:
		l.FPS = 7
		l.BitStreamChance = 0.5
		l.InitialLoot = 5
		l.LootSpawnRate = 0.02
		l.ViewDist = 11.5
		l.WinConditions = []WinCondition{
			{
				Type:   LootTypeDelta,
				Amount: 1000,
			},
			{
				Type:   LootTypeLambda,
				Amount: 1000,
			},
			{
				Type:   LootTypeSigma,
				Amount: 500,
			},
			{
				Type:   LootTypeOmega,
				Amount: 100,
			},
		}
		l.LootTable = map[LootType]float32{
			LootTypeDelta:  0.40,
			LootTypeLambda: 0.25,
			LootTypeSigma:  0.20,
			LootTypeOmega:  0.15,
		}
		l.DataMultipliers = map[LootType]float32{
			LootTypeDelta:  3,
			LootTypeLambda: 3,
			LootTypeSigma:  1.8,
			LootTypeOmega:  1.2,
		}
		l.Updater = newRandomBitStream(rotatingBitStream(10*time.Second, 5*time.Second, 20*time.Second)...)
	}
	return l
}
